set serveroutput on size unlimited buffer 100000 verify off timing on scan on

ACCEPT p_db_link PROMPT "Enter db link for source database: "
ACCEPT p_src_schema PROMPT "Enter source schema(s) to import, delimited by comma. [all, if not specified]: "
ACCEPT p_target_schema PROMPT "Enter target schema(s) to import, delimited by comma. [all, if not specified]: "
ACCEPT p_dir PROMPT "Enter Oracle directory name with dump files. [DATA_PUMP_DIR]: "
ACCEPT p_dump PROMPT "Enter dump file (or files mask): "
ACCEPT p_job PROMPT "Enter name for import job. [If not specified it will be autogenerated]: "
ACCEPT p_tables PROMPT "Enter list of tables to import. [If not specified all tables will be imported]: "
ACCEPT p_table_exists_action PROMPT "Enter action if table exists in target schema (APPEND, SKIP, REPLACE or TRUNCATE). [TRUNCATE]: "

set term off

variable v_job  varchar2(255)

column p_src_schema new_value p_src_schema
column p_target_schema new_value p_target_schema
column p_dir new_value p_dir
column p_tables new_value p_tables
column p_table_exists_action new_value p_table_exists_action
column p_job new_value p_job

SELECT upper(replace(trim('&p_src_schema'), ' ')) as p_src_schema, upper(replace(trim('&p_target_schema'), ' ')) as p_target_schema,
  nvl(upper('&p_dir'), 'DATA_PUMP_DIR') as p_dir, trim(replace(upper('&p_tables'), ' ')) as p_tables,
  nvl(upper('&p_table_exists_action'), 'TRUNCATE') as p_table_exists_action
FROM dual;

declare
  l_schema varchar2(1024) := '&p_target_schema';
  l_job    varchar2(255) := '&p_job';
  i        integer;
begin
  i := instr(l_target_schema, ',');
  if i > 0 then
    l_job := nvl(l_job, 'IMP_' || substr(l_schema, 1, i - 1) || '_' || to_char(systimestamp, 'YYYYMMDD'));
  else
    l_job := nvl(l_job, 'IMP_' || l_schema || '_' || to_char(systimestamp, 'YYYYMMDD'));
  end if;
  SELECT l_job INTO :v_job FROM dual;
end;
/

SELECT :v_job as p_job FROM dual;

set term on

PROMPT
PROMPT ===============================================
PROMPT You have selected:
PROMPT ===============================================
PROMPT      Source db link: &p_db_link
PROMPT    Source schema(s): &p_src_schema
PROMPT    Target schema(s): &p_target_schema
PROMPT           Directory: &p_dir
PROMPT        Dump file(s): &p_dump
PROMPT            Job name: &p_job
PROMPT              Tables: &p_tables
PROMPT Table exists action: &p_scn_desc
PROMPT

pause Press any key to start import and Ctrl-C to cancel further operations

declare
  l_handle integer;
  l_src_schema varchar2(1024) := '&p_src_schema';
  l_src_schemas varchar2(1024);
  l_target_schema varchar2(1024) := '&p_target_schema';
  l_target_schemas varchar2(1024);
  l_dir    varchar2(30) := '&p_dir';
  l_db_link varchar2(255) := '&p_db_link';
  l_dump   varchar2(255) := '&p_dump';
  l_job    varchar2(255) := '&p_job';
  l_tables varchar2(4000) := '&p_tables';
  l_table_exists_action varchar2(20) := '&p_table_exusts_action';
  l_mode   varchar2(10) := 'SCHEMA';


  l_data_ts varchar(30);
  l_users_ts varchar(30);
  l_gls_ts varchar(30);
  l_temp_ts varchar(30);

  cursor default_ts is
    SELECT default_tablespace, temporary_tablespace
    FROM dba_users
    WHERE username = upper(l_schema);

  l_ts varchar(30);
  l_tmp_ts varchar(30);

  function exists_ts(
    p_Name varchar2)
    return boolean
  as
    l_num integer;
  begin
    SELECT count(*) INTO l_num
    FROM dba_tablespaces
    WHERE tablespace_name = upper(p_Name);

    return l_num = 1;
  end exists_ts;

begin
  l_src_schemas := regexp_replace(replace(trim(l_src_schema), ' '), '(^|,)?([^,]+)(,|$)?', '\1''\2''\3');
  
  l_handle := dbms_datapump.open (operation => 'IMPORT', job_mode => 'SCHEMA', remote_link => l_db_link, job_name => l_job, version => 'COMPATIBLE');

  dbms_datapump.set_parallel(handle => l_handle, degree => 1);

  dbms_datapump.add_file(handle => l_handle, filename => 'IMP_' || l_dump || '.log', directory => l_dir, filetype => dbms_datapump.KU$_FILE_TYPE_LOG_FILE, reusefile => 1);
  if l_db_link is null then
    dbms_datapump.add_file(handle => l_handle, filename => l_dump, directory => l_dir, filetype => dbms_datapump.KU$_FILE_TYPE_DUMP_FILE);
  end if;

  dbms_datapump.set_parameter(handle => l_handle, name => 'KEEP_MASTER', value => 0);
  dbms_datapump.set_parameter(handle => l_handle, name => 'DATA_ACCESS_METHOD', value => 'AUTOMATIC');
  dbms_datapump.set_parameter(handle => l_handle, name => 'INCLUDE_METADATA', value => 1);
  if '&p_use_scn' = 'Y' then
    dbms_datapump.set_parameter(handle => l_handle, name => 'FLASHBACK_SCN', value => to_number('&p_scn'));
  end if;

  dbms_datapump.metadata_filter(handle => l_handle, name => 'SCHEMA_EXPR', value => 'IN(' || l_src_schemas || ')');
  dbms_datapump.metadata_filter(handle => l_handle, name => 'EXCLUDE_PATH_EXPR', value => 'IN(''AUDIT_OBJ'')');
  dbms_datapump.metadata_filter(handle => l_handle, name => 'NAME_EXPR', value => 'NOT LIKE ''SYS_PLSQL_%''', object_type => 'TYPE');

  dbms_datapump.log_entry(handle => l_handle, message => 'Export started at ' || to_char(systimestamp, 'DD.MM.YYYY HH24:MI:SS'), log_file_only => 1);
  dbms_datapump.log_entry(handle => l_handle, message => 'Job handle: ' || l_handle, log_file_only => 1);

  dbms_datapump.start_job(handle => l_handle, skip_current => 0, abort_step => 0, cluster_ok => 0);
  dbms_datapump.detach(handle => l_handle); 
exception when others then
  dbms_output.put_line(SQLERRM);
  begin
    dbms_datapump.stop_job(handle => l_handle, immediate => 1, keep_master => 0);
  exception when others then
    null;
  end;
end;
/


exit

set serveroutput on size 1000000 buffer 1000000 verify off timing on scan on autotrace off

declare
  l_handle     number;
  l_old_schema varchar2(30) := upper('&1');
  l_schema     varchar2(30) := upper('&2');
  l_dir        varchar2(30) := upper('&3');
  l_dump       varchar2(255) := '&4';
  l_job        varchar2(255);

  l_data_ts varchar(30);
  l_users_ts varchar(30);
  l_gls_ts varchar(30);
  l_temp_ts varchar(30);

  cursor default_ts is
    SELECT default_tablespace, temporary_tablespace
    FROM dba_users
    WHERE username = upper(l_schema);

  l_ts varchar(30);
  l_tmp_ts varchar(30);

  function exists_ts(
    p_Name varchar2)
    return boolean
  as
    l_num integer;
  begin
    SELECT count(*) INTO l_num
    FROM dba_tablespaces
    WHERE tablespace_name = upper(p_Name);

    return l_num = 1;
  end exists_ts;

begin
  l_job := 'IMPORT_' || l_schema || '_' || to_char(systimestamp, 'YYYYMMDD');

  open default_ts;
  fetch default_ts into l_ts, l_tmp_ts;
  close default_ts;

  l_data_ts := nvl(l_ts, 'USERS');
  l_users_ts := nvl(l_ts, 'USERS');
  l_gls_ts := nvl(l_ts, 'USERS');
  l_temp_ts := nvl(l_tmp_ts, 'TEMP');

  l_handle := dbms_datapump.open (operation => 'IMPORT', job_mode => 'SCHEMA', job_name => l_job, version => 'COMPATIBLE');
  dbms_datapump.set_parallel(handle => l_handle, degree => 1);
  dbms_datapump.add_file(handle => l_handle, filename => l_job || '.log', directory => l_dir, filetype => dbms_datapump.KU$_FILE_TYPE_LOG_FILE);
  dbms_datapump.set_parameter(handle => l_handle, name => 'KEEP_MASTER', value => 0);
  dbms_datapump.add_file(handle => l_handle, filename => l_dump, directory => l_dir, filetype => dbms_datapump.KU$_FILE_TYPE_DUMP_FILE);
  dbms_datapump.metadata_filter(handle => l_handle, name => 'SCHEMA_EXPR', value => 'IN(''' || l_old_schema || ''')');
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_SCHEMA', old_value => l_old_schema, value => l_schema);
  if exists_ts(l_schema || '_DATA') then
    l_data_ts := l_schema || '_DATA';
  end if;
  if exists_ts(l_schema || '_USERS') then
    l_users_ts := l_schema || '_USERS';
  end if;
  if exists_ts(l_schema || '_GLS') then
    l_gls_ts := l_schema || '_GLS';
  end if;
  if exists_ts(l_schema || '_TEMP') then
    l_temp_ts := l_schema || '_TEMP';
  end if;
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema, value => l_data_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_TS', value => l_data_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_DATA', value => l_data_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_INDEX', value => l_data_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_GLS', value => l_gls_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_USERS', value => l_users_ts);
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => 'NEXT_GEN_ASM1', value => l_data_ts);
  if l_users_ts <> 'USERS' then
    dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => 'USERS', value => l_users_ts);
  end if;
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => l_old_schema || '_TEMP', value => l_temp_ts);
  if l_temp_ts <> 'TEMP' then
    dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => 'TEMP', value => l_temp_ts);
  end if;
  dbms_datapump.metadata_remap(handle => l_handle, name => 'REMAP_TABLESPACE', old_value => '%', value => l_data_ts);
  dbms_datapump.set_parameter(handle => l_handle, name => 'DATA_ACCESS_METHOD', value => 'AUTOMATIC');
  dbms_datapump.set_parameter(handle => l_handle, name => 'INCLUDE_METADATA', value => 1);
  dbms_datapump.set_parameter(handle => l_handle, name => 'TABLE_EXISTS_ACTION', value => 'SKIP');
  dbms_datapump.set_parameter(handle => l_handle, name => 'SKIP_UNUSABLE_INDEXES', value => 0);
  dbms_datapump.metadata_transform(handle => l_handle, name => 'OID', value => 0);
  dbms_datapump.metadata_filter(handle => l_handle, name => 'EXCLUDE_PATH_EXPR', value => 'IN(''AUDIT_OBJ'')');
  dbms_datapump.metadata_filter(handle => l_handle, name => 'NAME_EXPR', value => 'NOT LIKE ''SYS_PLSQL_%''', object_type => 'TYPE');

  dbms_datapump.log_entry(handle => l_handle, message => 'Import started at ' || to_char(systimestamp, 'DD.MM.YYYY HH24:MI:SS'), log_file_only => 1);
  dbms_datapump.log_entry(handle => l_handle, message => 'Job handle: ' || l_handle, log_file_only => 1);

  dbms_datapump.start_job(handle => l_handle, skip_current => 0, abort_step => 0, cluster_ok => 0);
  dbms_datapump.detach(handle => l_handle);
end;
/


, remote_link => 'LS_PROD_EDC.THOMSON_SCIENTIFIC'

declare
  h1   NUMBER;
begin
     h1 := dbms_datapump.open (operation => 'IMPORT', job_mode => 'SCHEMA', remote_link => 'LS_PROD_EDC.THOMSON_SCIENTIFIC', job_name => 'IMPORT_TPHARMA_20121225', version => 'COMPATIBLE'); 
    dbms_datapump.set_parallel(handle => h1, degree => 1); 
    dbms_datapump.add_file(handle => h1, filename => 'IMPORT_TPHARMA_20121225.log', directory => 'SHARED_BACKUP_DIR', filetype => 3); 
    dbms_datapump.set_parameter(handle => h1, name => 'KEEP_MASTER', value => 0); 
    dbms_datapump.metadata_filter(handle => h1, name => 'SCHEMA_EXPR', value => 'IN(''TPHARMA'',''TPHARMA_ADMIN'')'); 
    dbms_datapump.set_parameter(handle => h1, name => 'ESTIMATE', value => 'BLOCKS'); 
    dbms_datapump.set_parameter(handle => h1, name => 'INCLUDE_METADATA', value => 1); 
    dbms_datapump.set_parameter(handle => h1, name => 'TABLE_EXISTS_ACTION', value => 'REPLACE'); 
    dbms_datapump.set_parameter(handle => h1, name => 'SKIP_UNUSABLE_INDEXES', value => 0); 
    dbms_datapump.start_job(handle => h1, skip_current => 0, abort_step => 0); 
    dbms_datapump.detach(handle => h1); 
end;
/

